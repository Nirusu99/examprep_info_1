\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}

\begin{document}
\paragraph{\Large GBI Definitionen}
\large\subparagraph{\large RegEx}
\normalsize
\begin{flushleft}
    Wissenswertes:
    \begin{itemize}
        \item Hilfssymbole $:=$\textcolor{red}{$\{|,(,),\ast,\emptyset\}$}
        \item "$\ast$ vor $\cdot$ (Konkatenation)"
        \item "$\cdot$ vor Strich "|" (Oder)
        \item $\langle R \rangle$ ist die formale Sprache ist, welche mit $R$ gebildet werden kann
        \item $\langle \emptyset \rangle = \{\}$
        \item $\langle R_1| R_2 \rangle = \langle R_1 \rangle \cup \langle R_2 \rangle$
        \item $\langle R_1 \cdot R_2 \rangle =\langle R_1 \rangle \cdot \langle R_2 \rangle$
        \item $\langle R \ast \rangle = \langle R \rangle ^\ast$
        \item Es gibt \textbf{kein} $R+$ sondern $RR\ast$ Bsp.: Statt $(ab)+ \text{ einfach } ab(ab)\ast$
    \end{itemize}
    Bsp.: \\
    $R = a|b$ dann ist:
    \begin{align*}
        \langle R \rangle = \langle a | b \rangle = \langle a \rangle \cup \langle b \rangle = \{a\} \cup \{b\} = \{a,b\}
    \end{align*}
    $R = (a|b)\ast$ dann ist:
    \begin{align*}
        \langle R \rangle = \langle (a|b)\ast \rangle = \langle a | b \rangle^\ast = \{a,b\}^\ast
    \end{align*}
    $R = (a\ast b\ast)\ast$ dann ist:
    \begin{align*}
        \langle R \rangle &= \langle (a\ast b\ast)\ast \rangle = \langle a\ast b\ast\rangle^\ast \\
        &= (\langle a\ast\rangle\langle b\ast\rangle)^\ast = (\langle a\rangle^\ast\langle b\rangle^\ast)^\ast = (\{a\}^\ast\{b\}^\ast)^\ast \\
        &= \{a,b\}^\ast
    \end{align*}
\end{flushleft}
\large\subparagraph{\large Graphen}
\normalsize
\begin{flushleft}
    \vspace{0.5cm}
    \begin{itemize}
        \item Ein gerichteter Graph ist das Paar \textcolor{red}{$G = (V,E)$}
        \begin{itemize}
            \item \textcolor{red}{Knotenmenge $V$} ist endlich und nichtleer (V für engl. vertex)
            \item \textcolor{red}{Kantenmenge $E$} $\subseteq V \times V$  (E für engl. edge)
            \begin{itemize}
                \item muss damit auch endlich sein, darf aber leer sein
            \end{itemize}
        \end{itemize}
        \item \textcolor{red}{Pfade} können über mehrer Kanten führen
        \item \textcolor{red}{$V^{(+)}:$} Menge der nichtleeren Listen von Elementen aus V
        \item Ein Pfad ist \textcolor{red}{$p=(v_0,\dots ,v_n) \in V^{(+)}$} wenn für jedes $i \in \mathbb{Z}_n$ gilt: \textcolor{red}{$(v_i,v_{i+1})\in E$}
        \item Die Länge eines Pfades ist die Anzahl der Kanten
        \item $v_n$ von $v_0$ ist erreichbar, wenn ein Pfad $p = (v_0,\dots ,v_n)$ existiert
        \item Wenn der start und endpunkt identisch sind heißt der Pfad \textcolor{red}{geschlossen}
        \item Wenn der geschlossene Pfad größer gleich 1 ist, heißt er \textcolor{red}{Zyklus}
        \item Pfad heißt \textcolor{red}{wiederholungsfrei}, wenn
        \begin{itemize}
            \item der erste bis zum vorletzten Konten verschieden sind ($v_0,\dots ,v_{n-1}$)
            \item der zweite bis zum letzten Knoten verschieden sind ($v_1,\dots ,v_n$)
            \item der erste und letzte Knoten drüfen gleich sein ($v_0$ und $v_n$)
            \item Einfach: Außer der letzte und erste darf jeder Knoten nur einmal "betreten" werden
        \end{itemize}
        \item \textcolor{red}{azyklischer Graph}: kein Teilgraph ist zyklisch
        \item Ein Graph ist \textcolor{red}{streng zusammenhängend} wenn
        \begin{itemize}
            \item zwischen jeden beliebigen zwei Knoten (Knotenpaar) aus dem Graphen ein Pfad existiert. Also jeder Punkt von jedem anderen Punkt (sich eingeschlossen) erreichbar ist. 
        \end{itemize}
        \item Ein Graph ist ein \textcolor{red}{gerichteter Baum} wenn:
        \begin{itemize}
            \item es eine \textcolor{red}{Wurzel $r \in V$} gibt, für die gilt:
            \begin{itemize}
                \item zu jedem Knoten existiert \textbf{genau} ein Pfad
                \item Wurzel ist immer \textbf{eindeutig}
            \end{itemize}
        \end{itemize}
        \item Der \textcolor{red}{Eingangsgrad} eines Knoten ist die Anzahl aller Kanten die zu dem Knoten hinführen
        \item Der \textcolor{red}{Ausgangsgrad} eines Knoten ist die Anzahl aller Kanten die von den Knoten wegführen
        \item Der \textcolor{red}{Grad} eines Knoten ist die Anzahl der Kanten des Knotens (Also Ausgangsgrad + Eingangsgrad)
        \item Knoten eines Baumes werden \textcolor{red}{Blätter} genannt, wenn Sie das Ende des Baumes sind, also Ausgangsgrad = 0
        \item \textcolor{red}{innere Knoten} sind dann alle mit Ausgangsgrad $>$ 0
        \item $E^n$ ist ein Pfad der länge $n$. Bsp.: $E^2$ ist ein Pfad der Länge 2
        \item $(x,y) \in E^2 \Leftrightarrow$ es existiert ein Pfad der Länge 2 von $x$ nach $y$
        \item Ein ungerichteter Graph hat einfach nur Kanten und keine "Richtungs" Pfeile
        \item Knotengrad für ungerichtete Graphen: man zählt alle "Kantenenden"
    \end{itemize}
    \vspace{1cm}
    Beispiel: \linebreak
    \linebreak
    \begin{tikzpicture}[-,auto,node distance=2cm,main node/.style={circle,draw,font=\Large}]
        \tikzset{every loop/.style={}}
        \node[main node] (1) {A};
        \node[main node] (2) [right of=1] {B};
        \path
            (1) edge (2)
            (2) edge[loop right] (2);
    \end{tikzpicture} \linebreak \linebreak
    $d(B) = 3$
\end{flushleft}
\subparagraph{\large Kontextfreie Grammatik}
\normalsize
\begin{flushleft}
    \begin{itemize}
        \item \textcolor{red}{$N$} sind alle \textcolor{red}{Nichtterminalsymbole}
        \item \textcolor{red}{$T$} sind alle \textcolor{red}{Terminalsymbole}
        \item $N \cap T = \emptyset$
        \item \textcolor{red}{$S$} ist der \textcolor{red}{Start} und $S \in N$
        \item \textcolor{red}{$P$ Produktionen}, endliche Menge und $P \in N \times V^\ast$
        \begin{itemize}
            \item $V = N \cup T$ die Menge aller Symbole
            \item Für jeder $(X,w) \in P $ schreibt man $X \rightarrow w$
            \item Man "ersetz" $P$ durch $w$
        \end{itemize}
        Bei einem \textcolor{red}{Ableitungsschritt} wird ein Terminalsymbol durch abgeleitet. Dieser wird dann mit "$\Rightarrow$" dargestellt, nicht mit Implikations verwechseln!
        \linebreak \linebreak Bsp.: \linebreak
        $G = (\{X\},\{$\textcolor{blue}{a},\textcolor{blue}{b}$\},X,P)$ mit $ P = \{X \rightarrow \epsilon,X \rightarrow $\textcolor{blue}{a}$X$\textcolor{blue}{b}$\}$ \linebreak
        \linebreak
        Dann gilt zB.: \textcolor{blue}{aba}$X$\textcolor{blue}{ba}$XXXX \Rightarrow$  \textcolor{blue}{aba}$X$\textcolor{blue}{baa}$X$b$XXX$ als Ableitungsschritt.
        (Man ersetzt das $X$ nach \textcolor{blue}{ba} mit \textcolor{blue}{a}$X$\textcolor{blue}{b}) \linebreak
        \linebreak
        Man kann auch einfach mit einem Index angeben, wie viele Ableitungsschritt getätigt werden. \linebreak
        $\Rightarrow^2$ aber auch $u \Rightarrow^\ast v$ wenn $v$ aus $u$ ableitbar ist. $\Rightarrow^0$ ist einfach wieder das selbe.
        \begin{itemize}
            \item Eine \textcolor{red}{Grammatik} erzeugt eine \textcolor{red}{formale Sprache}, also einfach alle Wörter die man aus einer Grammtik ableiten kann.
            \item $G = (N,T,S,P)$ erzeugt die formale Sprache $L(G) = \{w \in T^* | S \Rightarrow^\ast w\}$
            \item Diese formalen Sprachen heißen \textcolor{red}{kontextfrei}
        \end{itemize}
    \end{itemize}
\end{flushleft}
\large\subparagraph{\large Turing-Mschinen}
\normalsize
\begin{flushleft}
    Eine Turingmaschine ist im Grunde einfach nur ein spezieller Automat. Die Besonderheit der Turingmaschinen ist das "Speicherband", der
    "Schreib-Lese-Kopf" und die Anweisungen für den Schreib-Lese-Kopf in der Ausgabe.
    \begin{itemize}
        \item Das Speicherband ist in einzelne Zellen eingeteilt (Wie ein Array) das nach links und rechts "unendlich" ist.
        \item Eine leere Zelle wird mit dem Symbol $\square$ markiert.
        \item Der Schreib-Lese-Kopf zeigt immer auf eine Zelle im Speicherband und auf einen Zustand in der Turingmaschine.
        \item Die Eingabe ist der Inhalt der Zelle, auf welche der Schreib-Lese-Kopf zeigt, und die Ausgabe wird eben in diese nun geschrieben. Dabei gibt es in der Ausgabe zwei Anweisungen:
        \begin{itemize}
            \item $L$ Der Schreib-Lese-Kopf wird um eins nach links verschoben.
            \item $R$ Der Schreib-Lese-Kopf wird um eins nach rechts verschoben.
        \end{itemize}
        \item Eine Turingmaschine muss nicht jedes Szenario abhandeln können. Im Falle eines unbehandelten Falles bleibt die Turingmaschine einfach stehen.
        \item Wenn man zB. nun ein Wort in die Turingmaschine geben möchte, muss man dieses Wort einfach auf das Speicherband schreiben.
    \end{itemize}
    \includegraphics[width=0.8\textwidth]{simple_turing.png} \\
    Hier sieht man eine simple Turingmaschine mit einem einzigen Zustand $Z$. Die Zellen unter dem Zustand sind das Speicherband mit der Eingabe. Der Pfeil symbolisiert den Schreib-Lese-Kopf.
    Aktuell befindet sich die Turingmaschine im Zustand $Z$ und liest/schreibt in die erste Zelle des Speicherbandes.
    \pagebreak
    \linebreak
    Jede Turingmaschine kann zu einer Tabelle umgeschrieben, das Beispiel sollte fürs Verständnis ausreichen:
    \includegraphics[width=0.8\textwidth]{turing_table.png} \\
    Die rechte Spalte repräsentiert die mögliche Eingabe ($1$ oder $\square$). Die obere Zeile sind die verschiedenen Zustände ($A,B,C,H$).
    In die Tabelle wird dann Eingetragen was welcher Zustand für welche Eingabe macht. \\
    zB. für die Eingabe $\square$ in Zustand $A$, schreibt der Schreib-Lese-Kopf eine $1$ in die Zelle des Speicherbandes, das $R$ bewegt den Schreib-Lese-Kopf eins nach rechts und der Zustand wechselt zu Zustand $B$.
\end{flushleft}
\end{document}